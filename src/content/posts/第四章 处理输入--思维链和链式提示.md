---
title: "第四章 处理输入--思维链和链式提示"
description: "本文介绍了思维链和链式提示的概念，以及如何在大模型应用中实现这些技术以提升模型的推理能力"
published: 2026-01-23
pubDate: 2026-01-23
date: 2025-01-23
draft: false
tags: ["LLM", "Python", "LLM QA System"]
category: "大模型应用"
author: "0x3a0"
sourceLink: "https://github.com/0x3a0/blog/src/posts/第四章 处理输入--思维链和链式提示.md"
---

# 处理用户输入
## 思维链(COT)
思维链是一种引导语言模型逐步推理的Prompt设计技巧，预先通过人为设定系统Prompt，要求模型在给出最终结论之前，先明确各个推理步骤，目的是为了提升模型在复杂推理任务上的准确度。大致框架如下：

```python
delimiter = "####"

system_message = f"""
按照以下步骤回答用户的提问，用户的提问将以{delimiter}分隔。

步骤1：xxxx
步骤2：xxxxx
步骤3：xxxx
...

使用以下格式回答问题：
步骤1：<步骤1的推理>
步骤2：<步骤2的推理>
...

"""
```

通过详细的思维链提示，能够让模型模拟人类解决复杂问题的思维过程，按照预先设定的步骤逐步论证，减少模型匆忙得出错误结论的情况发生，使语言模型生成的结论更加可靠。

## 链式提示(Prompt Chaining)
链式提示是将复杂Prompt任务拆解为多个简单Prompt任务的策略，链式提示具有以下优点：

1. 拆解后的每个Prompt仅处理一个子任务，有助于提高模型完成任务的成功率。类似分阶段解题，而不是试图一次完成全部。
2. 降低token消耗。过长的Prompt会使用更多的token，拆分Prompt可以降低不必要的token消耗。
3. 结合工具调用。不同的Prompt可以通过function call或MCP调用不同的工具、数据库等外部资源。
4. 更灵活的工作流程。根据不同情况可以进行不同操作。

这就是为什么可以通过思维链推理一次性完成，却还要将任务拆分为多个子任务的原因。链式提示通过将复杂任务进行科学拆分，使语言模型集中处理单一子任务，减少模型负载的同时提高成功率。以下是一个简单的例子：

```python
delimiter = '####'  
  
# 第一轮  
system_message = f"""  
    你是一个产品专家，当用户的原始需求模糊时，请提出3-5个关键问题，帮助用户明确需求范围和技术选型。  
    用户的输入将使用{delimiter}作为分隔符。  
"""  
  
user_message_1 = '我想使用nodejs开发一个cs饰品市场监控的web项目'  
  
messages_1 = [  
    {  
        'role': 'system',  
        'content': system_message  
    },  
    {  
        'role': 'user',  
        'content': f'{delimiter}{user_message_1}{delimiter}'  
    }  
]  
  
completion_1 = get_completion(messages_1)  
print('用户原始需求 > ', user_message_1)  
print('大模型答复(completion_1) > ', completion_1)
```

例子中模拟用户想借助AI完成一个项目开发，当用户提问模糊时，模型会向用户询问该项目几个相关的问题。帮助用户明确开发需求。模型回复如下：

```plain
用户原始需求 >  我想使用nodejs开发一个cs饰品市场监控的web项目
大模型答复(completion_1) >  根据你的描述，这是一个典型的**全栈项目**，涉及定时任务（爬虫/API轮询）、数据存储和Web展示。

为了帮你梳理出一个可行的开发方案，我需要明确以下几个核心维度：

#### 1. 监控数据的来源 (Data Source)
这是最关键的技术选型问题，决定了你的核心逻辑复杂度。
*   **API对接：** 你是打算对接 Steam 的官方 WebAPI (需要 Steam API Key)，还是使用第三方数据平台的 API（如 Buff、C5、IGXE 等提供的接口）？
*   **网页抓取 (Scraper)：** 如果没有 API 可用，你需要自己写爬虫去解析 HTML，这通常反爬机制较强，你是打算处理哪种情况？

#### 2. 监控的频率与实时性 (Frequency & Real-time)
*   **频率要求：** 你希望多久刷新一次数据？是每秒/每分钟（高频，技术要求高），还是每小时/每天（低频，Serverless 或定时任务即可）？
*   **实时通知：** 当价格波动或有新库存时，你希望如何接收通知？是 Web 页面上的实时弹窗（需要 WebSocket），还是 邮件/Telegram/微信 推送？

#### 3. 项目规模与用户量 (Scale)
*   **目标用户：** 这是个人自用的工具，还是开放给公众使用的平台？
*   **并发量：** 如果是公众使用，预计会有多少人同时在线？这决定了数据库选型（SQLite 还是 MySQL/PostgreSQL）以及是否需要 Redis 做缓存。

#### 4. 监控的具体逻辑 (Business Logic)
*   **监控策略：** 你是监控特定饰品的**价格走势**，还是监控**求购单**（有人高价收），或者是监控**新上架的低价饰品**？
*   **过滤条件：** 是否需要根据磨损（久经/崭新）、模板、 stickers 贴纸 等属性进行过滤？

#### 5. 界面需求 (UI Scope)
*   **展示形式：** 只需要一个简单的数据列表，还是需要结合 ECharts 做 K线/价格趋势图？

---

**请针对以上问题提供一些背景信息，这样我可以为你推荐具体的 Node.js 技术栈（例如：Express + Puppeteer + MySQL 还是 NestJS + Axios + MongoDB）。**
```

以上信息为用户提问和模型回答，模型向用户提问了5个关于此项目的开发细节，并要求用户针对以上问题进行回答。接着我们模拟用户回答，继续向模型提问信息

```python
# 第二轮  
user_message_2 = f"""  
    1. 我的数据是通过buff163等平台官方提供的API获取  
    2. 我需要监控自己账号的饰品价格、数量、饰品的市场在售数量、饰品的市场购买情况。需要网站触发通知的频率是实时的  
    3. 这是一个仅供我自己使用的项目，后续会开源到github等平台供更多人使用  
    4. 监控的饰品数量越多越好，到后面可能需要开发某个平台上所有饰品的监控（例如buff163、悠悠有品等）  
"""  
  
system_message_2 = f"""  
    你是一个高级程序员，请你根据以下提问的问题和用户回答，撰写一份简洁的产品文档，包含：目标、技术栈的选择、核心功能  
"""  
  
messages_2 = [  
    {  
        'role': 'system',  
        'content': system_message_2  
    },
    {  
        'role': 'user',  
        'content': f"""  
            上一轮模型的提问: {completion_1}  
            用户回答: {delimiter}{user_message_2}{delimiter}  
        """  
} 
]  
  
completion_2 = get_completion(messages_2)  
print('用户回答 > ', user_message_2)  
print('大模型答复(completion_2) > ', completion_2)
```

```plain
用户回答 >  
        1. 我的数据是通过buff163等平台官方提供的API获取
        2. 我需要监控自己账号的饰品价格、数量、饰品的市场在售数量、饰品的市场购买情况。需要网站触发通知的频率是实时的
        3. 这是一个仅供我自己使用的项目，后续会开源到github等平台供更多人使用
        4. 监控的饰品数量越多越好，到后面可能需要开发某个平台上所有饰品的监控（例如buff163、悠悠有品等）
    
大模型答复(completion_2) >  好的，根据你提供的详细需求，这是一个非常典型的**全栈实时数据监控与告警系统**。

由于这是一个**高性能、实时性要求高**且计划**开源**的项目，在技术选型上需要兼顾开发效率、并发处理能力和扩展性。

以下是为你定制的产品技术文档：

---

### CS 饰品市场实时监控系统 (CS-Market-Monitor)

#### 1. 项目目标 (Goal)
构建一个高性能的 Node.js Web 应用，通过对接第三方交易平台（Buff163 等）的官方 API，实现对指定账号/饰品的**实时数据采集**、**趋势分析**与**多渠道告警**。系统需具备处理高并发监控任务的能力，并为后续扩展至全平台全量监控打下架构基础。

#### 2. 技术栈选择 (Technology Stack)

为了满足“实时性”和“高并发”的需求，我们采用 **Node.js (TypeScript) + 异步任务队列 + 高性能数据库** 的架构。

*   **后端框架：NestJS**
    *   *理由：* 结构化强，内置依赖注入、守卫、拦截器，非常适合构建企业级和长期维护的开源项目。对 TypeScript 支持最好。
*   **数据库 (主存储)：PostgreSQL**
    *   *理由：* 相比 MySQL，PostgreSQL 对 JSONB 数据类型支持极佳（适合存储 API 返回的复杂饰品元数据），且在处理大量时间序列数据（价格历史）时性能更稳定。
*   **缓存/实时消息队列：Redis**
    *   *理由：* **核心组件**。用于存储最新的饰品快照（减少 DB 压力），以及作为 WebSocket 的 Pub/Sub 消息通道。后续做全网监控时，Redis 也是任务队列的首选。
*   **定时任务调度：BullMQ (基于 Redis)**
    *   *理由：* Node.js 生态最强的任务队列。支持延迟任务、重试机制、并发控制。非常适合“轮询 API”这种场景，避免直接使用 `setInterval` 导致的内存泄漏和失控。
*   **前端框架：Next.js (React) 或 Vue3**
    *   *理由：* 配合 TailwindCSS 快速构建响应式仪表盘。如果需要实时图表，Next.js 集成 ECharts 会非常方便。
*   **实时通信：WebSocket (Socket.io)**
    *   *理由：* 实现服务端向浏览器的“服务器推送”，满足你要求的**实时触发通知**。

#### 3. 核心功能 (Core Features)

根据你的需求，我们将系统划分为以下四个核心模块：

**A. 采集引擎 (Data Collector)**
*   **API 适配器：** 编写通用的适配器接口（Adapter Pattern），目前针对 Buff163，预留其他平台（悠悠有品、C5）的接口规范。
*   **动态轮询策略：**
    *   **账号级监控：** 定时拉取“我的库存”和“我的在售”数据。
    *   **市场级监控：** 针对特定高价值饰品，轮询其市场在售列表（Order Book）和历史成交。
*   **并发控制：** 利用 `P-Queue` 或 `BullMQ` 限制并发请求数，防止因请求过快导致 IP 被封禁或触发 API 限流。

**B. 实时计算与存储 (Real-time Processor)**
*   **数据快照：** 将 API 返回的 JSON 数据解析后，存入 PostgreSQL。
*   **状态对比：** 每次拉取新数据后，与 Redis 中的“上一次状态”进行比对。
*   **Diff逻辑：** 价格变动 > X%？库存减少（已售出）？在售数量变化？新上架？
*   **趋势计算：** 记录 N 分钟内的价格中位数、最低价、求购价。

**C. 实时通知与告警 (Notification System)**
*   **WebSocket 推送：** 当后台检测到“已售出”、“价格剧烈波动”或“出现低价扫货机会”时，通过 WebSocket 立即向前端推送消息。
*   **前端 UI 响应：** 浏览器端收到消息后，播放提示音、弹出 Toast 通知、高亮变化的行数据。
*   **(扩展预留) Webhook/邮件：** 为未来可能增加的外部通知（如钉钉、Telegram 机器人）预留接口。

**D. 仪表盘 (Dashboard)**
*   **实时列表：** 展示监控饰品的当前价格、在售数量、24H 成交量。
*   **历史图表：** 点击单个饰品，展示价格走势折线图（基于 ECharts）。
*   **操作面板：** 允许动态添加/删除监控的 `goods_id` 或 `asset_id`。

---

**下一步建议：**
由于该项目涉及对接付费或受限的官方 API，建议先从 **账号库存监控**（获取 `/user/inventory`）和 **单饰品行情监控**（获取 `/commodity/price_history`）这两个最基础的 API 开始搭建 MVP（最小可行性产品）。

需要我为你生成项目的 `package.json` 初始依赖列表或项目目录结构设计吗？
```

以上就是完整的Prompt chaining例子，你仍然可以在此基础上添加更多更能，例如网络搜索、读取知识库信息等。不难看出，思维链和链式提示都有一个缺点，需要人工设置system prompt，每一步都需要开发者精心设计。  
[https://www.reddit.com/r/PromptEngineering/comments/1nb0o22?utm_source=chatgpt.com](https://www.reddit.com/r/PromptEngineering/comments/1nb0o22?utm_source=chatgpt.com)

